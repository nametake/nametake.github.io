<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on nametake.info</title>
    <link>https://nametake.github.io/posts/</link>
    <description>Recent content in Posts on nametake.info</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Jun 2019 23:50:36 +0900</lastBuildDate>
    
	<atom:link href="https://nametake.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>FormikとYupを使った動的フォームのバリデーション</title>
      <link>https://nametake.github.io/posts/2019/06/05/formik-yup-dynamic-validation/</link>
      <pubDate>Wed, 05 Jun 2019 23:50:36 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/06/05/formik-yup-dynamic-validation/</guid>
      <description>Formikで動的なFormを作った時に、表示されるFormに応じてYupのバリデーションを切り替える方法でちょっと手間取ったのでメモ。
結論から言うとYup.lazy()を使って遅延評価されるValidationSchemaを使えば解決した。Yup.lazy()に渡ってくるFormの値を元にValidationwSchemaを表示されるFormに対応したValidationSchemaを返せば狙った挙動が実現できた。
サンプルコードは以下。
 </description>
    </item>
    
    <item>
      <title>インライン要素の高さを合わせるCSS定義</title>
      <link>https://nametake.github.io/posts/2019/05/29/inline-center/</link>
      <pubDate>Wed, 29 May 2019 15:47:35 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/05/29/inline-center/</guid>
      <description>ラジオボタンとラベルの高さを合わせるCSS定義を何回も調べている気がするのでメモ。
たぶん下の書き方が一番モダンな気がする。
display: inline-flex; align-items: center;</description>
    </item>
    
    <item>
      <title>Type SafeなReducerの書き方</title>
      <link>https://nametake.github.io/posts/2019/05/18/type-safe-reducer/</link>
      <pubDate>Sat, 18 May 2019 10:38:55 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/05/18/type-safe-reducer/</guid>
      <description>以前書いた記事で書いたReducerでは、受け取ったActionの型を判別するためには、switchで分岐した後にそれに対応したActionの型でキャストをする必要があった。
const todoReducer: Reducer&amp;lt;ITodoState&amp;gt; = ( state: ITodoState = initTodoState, action: TodoAction ): ITodoState =&amp;gt; { switch (action.type) { case TodoActionType.ADD_TODO: const addTodoAction: IAddTodoAction = action; // &amp;lt;-- ここでキャストしている  return { ...state, todos: state.todos.concat([addTodoAction.payload.todo]) }; default: return state; } }; この方法だと、action.typeとそれに対応する型を実装者が気にしなければならず、型安全とは言い難かった。
このあたりの話を某Slackで相談したら、以下のような Flux standard actionのtypeやpayloadをジェネリクスで指定するようにして、typeにenumを使うというやり方を教えてもらった。
import { Reducer } from &amp;#39;redux&amp;#39;; // Flux standard action interface Action&amp;lt;TType, TPayload = null, TMeta = undefined&amp;gt; { type: TType; payload: TPayload; meta?: TMeta; } enum ActionType { ADD, DELETE } type AddAction = Action&amp;lt;ActionType.</description>
    </item>
    
    <item>
      <title>IntelliJのPopupの候補を展開するKeymap</title>
      <link>https://nametake.github.io/posts/2019/01/20/intellij-popup-expand/</link>
      <pubDate>Sun, 20 Jan 2019 21:05:06 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/01/20/intellij-popup-expand/</guid>
      <description>自分は普段Vimでの補完候補を&amp;lt;C-k&amp;gt;で展開しているがIntelliJでの補完候補も同じコマンドで展開したかったのでメモ。
結論だけいうと、Editor Actions -&amp;gt; Choose Lookup ItemにKeymapを設定すればできた。
本当は.ideavimrcだけに設定したかったが、ここまで調べるのに少し時間がかかったので後で調べる。</description>
    </item>
    
    <item>
      <title>labelerrとsuberrを作った話をLTしてきた</title>
      <link>https://nametake.github.io/posts/2018/12/19/created-labelerr-and-suberr/</link>
      <pubDate>Wed, 19 Dec 2018 11:37:17 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/19/created-labelerr-and-suberr/</guid>
      <description>golang.tokyo #20のLT大会で、labelerrとsuberrを作った話をしてきました。
 「Goのerrorは1種類というのは綺麗だとは思うけど、実運用上errorに重み付けをしたいよね」ってところからこのライブラリの出発点です。
スライド内にもありますが、Primitiveな型しか取り扱わないように気をつけている上に、ライブラリ自体も難しいことはしてないので、なんとなく使ってみるか、ぐらいの感覚で使ってもらうと嬉しいです。</description>
    </item>
    
    <item>
      <title>Goでのprotocプラグインのテストの書き方</title>
      <link>https://nametake.github.io/posts/2018/12/14/protoc-plugin-test/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/14/protoc-plugin-test/</guid>
      <description>最近周りでProtocol Buffersの話題をよく聞くようになりました。
ということはそろそろ人類はprotocのプラグインをGoで書きたくなる時代がやってくると思います。
そのときに世の中に生み出されるプラグインの品質が少しでも高くなればと思い、以前protoc-gen-gohttpというプラグイン作ったときにテストも書いたので、その知見を書こうと思います。
プラグイン自体は@yuguiさんの「protocプラグインの書き方」がとても参考になったのでそちらを参照すると良いかもしれません。
TL;DR  Goのコードでprotoファイルをplugin.CodeGeneratorRequestに変換することは(恐らく)できない プラグインの動作テストはテスト内でprotocコマンドを実行して行う 実行結果の確認はGolden testingで行う 細かいやり方はgithub.com/golang/protobuf/blob/master/protoc-gen-go/golden_test.goに書いてある  自分のプラグインのテストもそれを参考にして書いた   経緯(読み飛ばして大丈夫です) protocのプラグインは標準入力に入ってきたデータをproto.CodeGeneratorRequest型にUnmarshalしてprotoファイルの情報を取得します。
そのため、最初にテストを書こうとしたときにはGoだけでprotoファイルをproto.CodeGeneratorRequestに変換する仕組みがあるのかと思っていたのですが、この記事公開時点ではその仕組みは提供されていないようでした(知ってたらコメント等で教えていただけると助かります)。
「それじゃあ有名なプラグインはどうやってるんだ?」と思いprotoc-gen-goのコードを見てみると、Goのコードの中で直接protocコマンドを実行していて、少し面白いテストをしていたので解説しようと思います。
golden_test.goの解説 ファイル名から想像できる通り、いわゆるGolden testingと呼ばれるものです。テストの中からprotocコマンドを直接実行して、その結果の出力ファイルとtestdataディレクトリに入っている期待するファイルとを比較をしてテストしています。
300行ぐらいなので全部読んでもそんなに時間はかからないと思いますが、簡単に解説をしてみようと思います。
コマンド実行部分 以下のコードが直接コマンドを実行する部分です。testing.T構造体とprotocに与える引数を受け取って実際にコマンドを実行します。
func protoc(t *testing.T, args []string) { cmd := exec.Command(&amp;#34;protoc&amp;#34;, &amp;#34;--plugin=protoc-gen-go=&amp;#34;+os.Args[0]) cmd.Args = append(cmd.Args, args...) // We set the RUN_AS_PROTOC_GEN_GO environment variable to indicate that 	// the subprocess should act as a proto compiler rather than a test. 	cmd.Env = append(os.Environ(), &amp;#34;RUN_AS_PROTOC_GEN_GO=1&amp;#34;) out, err := cmd.</description>
    </item>
    
    <item>
      <title>TypeScript&#43;React&#43;Reduxチュートリアル</title>
      <link>https://nametake.github.io/posts/2018/12/05/typescript-react-redux-tutorial/</link>
      <pubDate>Wed, 05 Dec 2018 11:08:00 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/05/typescript-react-redux-tutorial/</guid>
      <description>普段は Go でサーバサイドのコードを書いているのですが、TypeScript+React+Redux を勉強する機会がありました。
その際、巷に溢れているチュートリアルやサンプルコードで型で縛っているものが少なすぎて、理解にかなり苦労したので自分なりに Todo アプリケーションを作るチュートリアルを書いておきます。
このチュートリアルは以下のことを意識して書かれています。
 引数や返り値は型で縛る  データフローの理解を重視する  外部ライブラリは以下の 3 つしか import しない  react redux react-redux  標準の設計になるべく則る  また、この記事では以下のことについては深く言及はしません
 nodeのツールのエコシステム TypeScript の記法 JSX の記法 React+Redux の概念  プロジェクトの準備 まずはプロジェクトを準備します。
node と yarn は入っている前提で進めます。
Facebook が公式で用意しているアプリケーション作成ツールを使用してプロジェクトテンプレートを作ります。
npx create-react-app todo-app --scripts-version=react-scripts-ts 次にプロジェクトのディレクトリに移動して以下のツールをインストールします。
cd todo-app yarn add redux react-redux yarn add -D @types/redux @types/react-redux @types がついているパッケージは、/以下のパッケージの型情報が記述されているパッケージです。開発時しか使用しないので-Dオプションを付けてインストールします。
以下のコマンドでローカルサーバが立ち上がり、ブラウザに画面が表示されれば問題ありません。
yarn start チュートリアルのコードは作成されたプロジェクト内部の src ディレクトリに記述していきます。
Component の実装 何はともあれ何かが表示されてないとモチベーションが上がらないのでブラウザに見た目を表示させます。</description>
    </item>
    
    <item>
      <title>VimConf2018感想</title>
      <link>https://nametake.github.io/posts/2018/11/24/vimconf2018/</link>
      <pubDate>Sat, 24 Nov 2018 10:15:34 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/24/vimconf2018/</guid>
      <description>11月24日にあったVimConf2018に行ったので参加ブログを書きます。
Keynote - What is the next feature?(o) スライド
mattnさんの発表。
vim-jpの起こりの話や
Keynote - Vim: From hjkl to a platform for plugins 楽しみにしていたBram氏の発表。
Vimの歴史とこれからのVimの話をされていた。
非常に勝手ながらにあまりプラグインにはそこまで強い興味がないかと思っていたが、 発表で言及されていた「これからのVim」はプラグインに関することが多く、少し驚いた。
発表の内容からも、終始開発者として「使う人」のことを強く意識しながらVimのこれからを考えていることが伝わった。
個人的にはVSCodeのPopup Windowが羨ましいのでPopUp Windowがほしいです。
Migrating plugins to standard features  この発表の聽いたので帰ってからVimのプラグインを10個削りました。
Modes  デバッグのお話。
この話を聽いてDelveのプラグインを思い出したのでちょっとあとで試そうと思う。
A day in the life of (ordinary) Vimmer  1日1回プラグインのアップデートは私もやります。
Modern editor-independent development environment for PHP Modern editor-independent development environment for PHP #vimconf / 黒點 さん - ニコナレ 宗教戦争好きですすみません。</description>
    </item>
    
    <item>
      <title>Protobufのservice定義をhttp.Handler対応させるprotoc-gen-gohttpを作った</title>
      <link>https://nametake.github.io/posts/2018/11/21/protoc-gen-gohttp/</link>
      <pubDate>Wed, 21 Nov 2018 16:32:07 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/21/protoc-gen-gohttp/</guid>
      <description>nametake/protoc-gen-gohttpというプラグインを作ったのでその話。 細かい使い方とかはREADMEに任せる。
なんで作ったの? Protocol Buffersのファイルにはserviceというものを定義できるが、どちらかというとgRPC向けの定義なので、Protocol Buffer on HTTPの構成でAPIサーバを作っていると活用できなくて勿体無いな〜とか思ってた。
protoc-gen-goのgRPCオプションを使ってビルドするとServerのinterfaceまでは吐き出してくれるので、「だったらこのinterfaceをhttp.Handlerに対応させればいいんじゃね？」という勢いで作ってみた。
コンセプト  RequestのBodyにJSONとProtobufのバイナリのどちらでも使えるようにする 生成される物が標準パッケージとProtobuf関係のパッケージしかimportしない 呼び出し毎に自由な処理を挟める(ログ等のため) errorが発生したときに自由にハンドリングができる 無駄にMarshal/Unmarshalをしない できる限り型で守る(Contextに情報を詰めたりしない)  何が嬉しいの? Protobufの定義にserviceを書いてこのプラグインを使うと、gRPCのServerをhttp.HandlerFuncに変換してくれるConverterが生成される。このConverterはgRPCのServerのinterfaceを必要とするため、メソッド定義も型で守れるようになる。
変換されたhttp.HandlerFuncはContent-Typeを見て、Marshal/Unmarshalするパッケージを切り替えるので、BodyにはJSONが詰められていてもProtobufのJSONが詰められていてもどっちでも大丈夫なようになっている(はず)(テストケース不足)。
また、http.HandlerFuncを抜けるときには、必要な情報を全部渡してコールバックを呼んでくれるので、1リクエスト毎に行いたい処理(ログ出力とか)を自分で定義できるようになる。errorも渡ってくるのでエラーを見て処理を変えたりもできる。
比較 このプラグインを作る前にいくつか調べたのでそれとの比較も書いてみる。
twrip 同じようにProtocol Buffersの定義からhttp.Handler対応をした上にContent−TypeをみてMarshal/Unmarshalをするパッケージを切り替えるライブラリだが、 以下の点が気になったので採用を見送った。
 生成されるものがtwripをimportしている エラー発生時のハンドリングの余地が少ない RPCの呼び出しに対するHookがContextに情報を詰める前提だった  個人的にはGoのライブラリなら、ライブラリに依存させる提供方法ではなく、標準パッケージに乗せられる提供方法のほうが良いと考えているので、生成したものがなにかに依存してしまうのは好ましくなかったため採用見送り。
RussellLuo/protoc-go-plugins Protocol Buffersの定義からhttp.Handler対応の物を生成するプラグインだが、protoのMarshal/Unmarshalには対応していなかった。
エラーハンドリングにも余地がなかったので採用見送り。
moul/protoc-gen-gotemplate Protocol Buffersの定義からGoのテンプレート機能を使ってコードを生成するためのプラグイン。
時間と労力をかけないならこれを使うのが一番早かった気はする。
プラグインの作成にめちゃくちゃ時間がかかるようだったらこれも検討していたが、そこまで時間がかかりそうでもなかったので勉強も兼ねて自作することにした。</description>
    </item>
    
    <item>
      <title>GCPの認証済みのhttp.Clientの取得方法</title>
      <link>https://nametake.github.io/posts/2018/11/09/auth-gcp-client/</link>
      <pubDate>Fri, 09 Nov 2018 11:15:24 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/09/auth-gcp-client/</guid>
      <description>GCPの認証済みのhttp.Clientが欲しいときにちょっとだけ調べたのでメモ。
結論だけ言うと、golang.org/x/oauth2/googleのDefaultClientを使えばよかった。
今回はDataflowのAPIを叩きたかったので以下のようにすればできた。
client, err := google.DefaultClient(ctx, dataflow.CloudPlatformScope) if err != nil { return fmt.Errorf(&amp;#34;failed create client: %v&amp;#34;, err) }</description>
    </item>
    
    <item>
      <title>neoformatでshfmtを使うときにインデントをタブ文字にしたい時の設定</title>
      <link>https://nametake.github.io/posts/2018/10/10/vim-shfmt-neoformat-indent/</link>
      <pubDate>Wed, 10 Oct 2018 11:44:32 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/10/10/vim-shfmt-neoformat-indent/</guid>
      <description>VimでShell scriptを書くにあたって、shfmtとneoformatで保存時に自動的にフォーマットされるように設定しているが、チームのコーディングルールでインデントをタブ文字にする必要があったときにちょっと引っかかったのでメモ。
neoformatでのshfmtはデフォルトだとインデントはスペースになる。
shfmtのヘルプの
-i uint indent: 0 for tabs (default), &amp;gt;0 for number of spaces という記述と、neoformatのshfmtの定義の
function! neoformat#formatters#sh#shfmt() abort return { \ &amp;#39;exe&amp;#39;: &amp;#39;shfmt&amp;#39;, \ &amp;#39;args&amp;#39;: [&amp;#39;-i &amp;#39; . shiftwidth()], \ &amp;#39;stdin&amp;#39;: 1, \ }endfunction から、とりあえずshiftwidthを0にしたらタブ文字になるかと思い、プロジェクトでのVimの設定を以下のように設定してみた(プロジェクト固有の設定ができるようにしている)。
autocmd Filetype sh setlocal sw=0 sts=0 noexpandtab しかし、どうしてもインデントがスペースになってしまうためちゃんとshiftwidth()の挙動を調べてみると、shiftwidthが0に設定されているとtabstopの値を使うようになっているらしい。
https://vim-jp.org/vimmagazine/2012/08/31/vimmagazine.html
tabstopは0を設定できないため、以下のようにneoformatのshfmt設定をプロジェクト固有の設定で上書きして対処した。
let g:neoformat_sh_shfmt = { \ &amp;#39;exe&amp;#39;: &amp;#39;shfmt&amp;#39;, \ &amp;#39;args&amp;#39;: [&amp;#39;-i&amp;#39;, 0], \ &amp;#39;stdin&amp;#39;: 1, \ }</description>
    </item>
    
    <item>
      <title>depでprivateリポジトリがupdateできなかったときの解決策</title>
      <link>https://nametake.github.io/posts/2018/09/20/dep-private-repo/</link>
      <pubDate>Thu, 20 Sep 2018 18:47:46 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/09/20/dep-private-repo/</guid>
      <description>Goをアップデートした後、dep updateをしたら以下のようなエラーが発生した。
grouped write of manifest, lock and vendor: error while writing out vendor tree: failed to write dep tree: failed to export github.com/nametake/private-repo: unable to update repository: remote: Repository not found. fatal: repository &amp;#39;https://github.com/nametake/private-repo/&amp;#39; not found : command failed: [git fetch --tags --prune origin]: exit status 128 make: *** [dep] Error 1 どうもprivateリポジトリをhttps経由でcloneしてこようとしているため起こっているっぽい。
以下のconfig設定をして、githubではhttpsで始まるURLをgitのURLを使うように書き換える設定を追加したら治った。
[url &amp;#34;git@github.com:&amp;#34;] insteadOf = https://github.com/ https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</description>
    </item>
    
    <item>
      <title>hugo&#43;github pagesにブログを移転したメモ</title>
      <link>https://nametake.github.io/posts/2018/09/15/hugo-github-pages/</link>
      <pubDate>Sat, 15 Sep 2018 12:20:26 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/09/15/hugo-github-pages/</guid>
      <description>大して書いていなかったブログをgithub pages+hugoの組み合わせに移行したのでそのメモ。
とは言うものの、ほとんどHugoの入門用ページの内容をそのままやっただけなのでその辺は割愛。
最終的なディレクトリ構成は以下。
blog ├── Makefile ├── archetypes │ ├── default.md │ └── posts.md ├── bin │ ├── deploy.sh │ └── new_post.sh ├── config.toml ├── content │ ├── about │ │ └── index.md │ └── posts │ └── 2018-09-15-hugo-github-pages │ └── index.md ├── public(submodule) ├── static │ ├── css │ │ └── index.css │ └── images │ └── avatar.jpg └── themes └── coder(submodule) config.toml 自分はパーマリンクを日付+自分で設定した英単語にしたかったので、以下のようにconfig.tomlに追記。
slugは各postのfrontmatter(postの先頭にあるヘッダ部分)に設定すると反映される。
posts = &amp;quot;/posts/:year/:month/:day/:slug&amp;quot;のpostsの部分はcontentディレクトリにあるpostsディレクトリと同じ名前にする必要があるので注意。</description>
    </item>
    
  </channel>
</rss>