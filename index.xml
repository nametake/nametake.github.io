<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nametake.info</title>
    <link>https://nametake.github.io/</link>
    <description>Recent content on nametake.info</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2019 01:52:26 +0900</lastBuildDate>
    
	<atom:link href="https://nametake.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>protoc-gen-gohttpをHttpRule Optionに対応させた</title>
      <link>https://nametake.github.io/posts/2019/08/30/protoc-gen-gohttp-httprule/</link>
      <pubDate>Fri, 30 Aug 2019 01:52:26 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/08/30/protoc-gen-gohttp-httprule/</guid>
      <description>以前、Protocol Buffersのserviceの定義を利用してGoのnet/httpで利用できるようにするためのprotoc-gen-gohttpというprotocのプラグインを作成しました。
ですが、protoc-gen-gohttpではURLのパス部分の定義はProtocol Buffersの定義には記述できないため、クライアント側がProtocol Buffersを見ただけでパスを読み取ることができませんでした。また、生成されたコードはHTTPのBodyしか参照しないため、情報を取得するだけのときもHTTPのメソッドをPOSTにする必要もありました。
そこで、Googleが提供しているRPCの定義をHTTPのREST APIにマッピングするためのHttpRuleオプションを利用して、protoc-gen-gohttpがHttpRuleのマッピングどおりに動作するコードを生成するように改良しました。
使い方 protoc-gen-gohttpをインストールしたら、以下のようにHttpRuleを使用したProtoの定義を用意します(annotations.protoのダウンロードの仕方はこの辺を参考にしてください)。この記事ではexample.protoに書いているとします。
syntax = &amp;#34;proto3&amp;#34;;package main;option go_package = &amp;#34;main&amp;#34;;import &amp;#34;google/api/annotations.proto&amp;#34;;service Messaging { rpc GetMessage(GetMessageRequest) returns (GetMessageResponse) { option (google.api.http).get = &amp;#34;/v1/messages/{message_id}&amp;#34;; } rpc UpdateMessage(UpdateMessageRequest) returns (UpdateMessageResponse) { option (google.api.http) = { put: &amp;#34;/v1/messages/{message_id}/{sub.subfield}&amp;#34; body: &amp;#34;*&amp;#34; }; }}message GetMessageRequest { string message_id = 1; string message = 2; repeated string tags = 3;}message GetMessageResponse { string message_id = 1; string message = 2; repeated string tags = 4;}message SubMessage { string subfield = 1;}message UpdateMessageRequest { string message_id = 1; SubMessage sub = 2; string message = 3;}message UpdateMessageResponse { string message_id = 1; SubMessage sub = 2; string message = 3;} 用意できたら、以下のコマンドでGoのコードを生成します。</description>
    </item>
    
    <item>
      <title>Protocol Buffersを使ったAPIでのNullの設計</title>
      <link>https://nametake.github.io/posts/2019/08/17/protobuf-null-api/</link>
      <pubDate>Sat, 17 Aug 2019 10:44:03 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/08/17/protobuf-null-api/</guid>
      <description>Protocol BuffersのNullの取り扱いの問題 Protocol Buffersのproto3の仕様ではmessageの中の値をOptionalで表現する記法がありません。値を詰めずに送ると入れ子の値がデフォルト値になってしまいます。
しかし、アプリケーションの設計によってはOptionalな値を表現する必要が出てきます。
そういった時、プリミティブな型ならgoogle/protobuf/wappers.protoを使う方法があります。
以下のように使うことでmsgはOptionalな値として取り扱えます。
syntax = &amp;#34;proto3&amp;#34;;package example;import &amp;#34;google/protobuf/wrappers.proto&amp;#34;;message Example { google.protobuf.StringValue msg = 1;} wappers.protoを読むと、google.protobuf.StringValueは内部にstringを持つmessageとして定義してあり、入れ子構造になったmessageはデフォルト値がnullになるという仕様を利用して擬似的にOptionalを表現する仕組みであるということがわかります。
しかし、プリミティブな型ではないmessageを定義して、それを入れ子構造にするようなmessageを定義すると、入れ子になったmessageのデフォルト値はnullであるという特性から、それがOptionalなのかRequiredなのかが分かりづらくなるという問題があります。
例えば、以下のようにDecimal 型が定義されたとき、それを入れ子構造にするようなOrder型があるとします。
syntax = &amp;#34;proto3&amp;#34;;package example;message Decimal { int64 value = 1; int64 exp = 2;}// アプリケーションに注文をするメッセージ message Order { // 支払う金額(Required)  Decimal amount = 1; // 通貨単位(Required)。  int64 currency_unit = 2; // 使用するポイント(Optional)  Decimal point = 3;} Order型では金銭を表現しているため数値を正確に表現できるDecimal型を使って金額とポイントを定義しています。しかし、アプリケーションの都合でamountはRequiredにpointはOptionalにしたいとき、どちらもデフォルト値がnullになってしまうため、そのままだと両方を同時に表現できません。また、0ポイントなのかnullなのかで挙動に明確な違いがある場合は0を送るという手段も成立しません。
Orderぐらいの定義量であればコメントやドキュメントで対応することもできます。しかし、生成されるコードがOptionalであるということは変わらないため、せっかく型付でコード生成をしてくれるProtocol Buffersのメリットが半減してしまいます。また、人類にドキュメントを書く読む管理するという行為は難しすぎるため、プロダクトの成長に従ってドキュメントは陳腐化していってしまいます。
解決策 DecimalをOptionalで表現するために以下のようなNullDecimal型を定義してみます。
message NullDecimal { bool hasValue = 1; Decimal decimal = 2;} 定義の通り、値を持っているかどうかを判別するhasValueと実際の値になるDecimal型を持っている型です。Goを書く方はピンとくるかもしれませんが、sql.</description>
    </item>
    
    <item>
      <title>Goの戻り値をいい感じに補完してくれるvim-snippetsを作った</title>
      <link>https://nametake.github.io/posts/2019/07/29/vim-goiferr-snippets/</link>
      <pubDate>Mon, 29 Jul 2019 22:57:06 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/07/29/vim-goiferr-snippets/</guid>
      <description>最近Vimの設定を整理してcoc.nvimに乗り換えるにあたり、snippetのプラグインもneosnippetからcoc-neosnippetに乗り換え、snippet集もvim-snippetsに変更しました。
概ね問題はなかったのですが、Goを書くときにiferrで戻り値をいい感じに補完してくれる機能がなくなったのは若干不便でした(参考)。
一応coc.nvimにneosnippetの機能を取り込む機能はついているようでしたがうまく動かなかったことと、もうちょっと高級な機能が欲しいと前々から思っていたのもあり、せっかくなのでsnippetを提供するプラグインを作りました。
それで作ったのが、vim-goiferr-snippetsです。以下のgifのように動作します。
iferrのsnippetに関して以下の機能を提供しています。
 戻り値の型を構造体でも補完してくれる 構造体がポインタかどうかを判別してくれる pkg/errorsのWrap関数でerrorをWrapする補完の提供 名前付き戻り値のときはreturnしか出力しない インラインのエラーハンドリング用snippetも提供 上記機能を持ったVimScirptの関数として提供している  pkg/errors以外のerrorライブラリ等でカスタマイズできる   また、作っている最中に「iferr用の正規表現はそのままreturnのsnippetとしても使えるのでは？」と思ったので、そのままreturnを補完するsnippetとしても提供しました。戻り値をいい感じに展開して、それぞれにジャンプ用のマーカーを付けているので、サクサク戻り値を設定できます。
自分用に作ったのでオレオレ設定な部分もありますが、生暖かい見ていただければ幸いです。
最後に、プラグイン内の正規表現部分は@pockeさんの「Vim で Go 言語を書いている時、Neosnippet でいい感じに if する」という記事を参考にさせていただきました！ありがとうございました！</description>
    </item>
    
    <item>
      <title>Project</title>
      <link>https://nametake.github.io/project/</link>
      <pubDate>Mon, 29 Jul 2019 00:14:54 +0900</pubDate>
      
      <guid>https://nametake.github.io/project/</guid>
      <description>作ったもの protoc-gen-gohttp Protocol Buffersの定義から生成されるGoのgRPC用interfaceをnet/http用に変換するコードを生成するprotocのプラグイン。詳しくは記事参照。
suberr/labelerr Goのエラーハンドリングを拡張するライブラリ。golang.tokyo #20で発表しました。
vim-goiferr-snippets/ctrlp-goimport GoのVimプラグインです。自分の使っているプラグインの足りない部分を補うような感じのものを作りました。</description>
    </item>
    
    <item>
      <title>Vimのプラグインを整理した(あとcoc.nvimの紹介)</title>
      <link>https://nametake.github.io/posts/2019/07/25/change-vim-plugins/</link>
      <pubDate>Thu, 25 Jul 2019 00:51:43 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/07/25/change-vim-plugins/</guid>
      <description>ちまちまとdotfilesを育ててきたんですが、Goの補完が動かなくなっていたり中途半端にLSP対応しようとした痕跡だけ残っていたりしたので、断捨離も兼ねてガッツリプラグインを整理しました。
プラグインの構成はdotfiles/vim/rc/plug.rc.vimに全部寄せています。
あんまり凝った構成にしてもメンテナンスが大変なので、以下の基準でプラグインを選びました。
 githubのStar数が多くてAPIが安定してそう 少ない設定でも動く  整理しているときに、coc.nvimという良さげな補完プラグインを見つけたので軽く紹介してみます。
coc.nvim coc.nvimはREADMEに書いてあるとおり、VSCodeライクな補完をVim上で実現するために作られているらしい。
高速と謳っているだけあり、重たいファイルを開いて補完を実行しても重くなりませでした。また、デフォルトでLSPに対応している上に、非常に丁寧なドキュメントも用意されているため、導入のハードルはとにかく低かったです。aleと共存するための設定があったのも個人的には嬉しい。
一部設定はJSONで管理することになりますが、それさえ問題なければ強くおすすめできます。
導入に際して、coc-snippetsをCocInstallではなく、プラグインマネージャ(vim-plug)経由でインストールしようとしたときにちょっとだけ引っかかったのでそれだけメモ。
coc.nvimと連携するエクステンションをプラグインマネージャ経由でインストールするときには、以下のようにインストール後にyarnコマンドを実行するようにする必要があります。
Plug &amp;#39;neoclide/coc-snippets&amp;#39;, {&amp;#39;do&amp;#39;: &amp;#39;yarn install --frozen-lockfile&amp;#39;} (ちなみにちゃんとドキュメントに書いてあるので、全部読んでおけば引っかかるようなこともないです)</description>
    </item>
    
    <item>
      <title>zshのPATHの順番をfish shellに引き継ぐ</title>
      <link>https://nametake.github.io/posts/2019/07/22/pass-zsh-path-to-fish/</link>
      <pubDate>Mon, 22 Jul 2019 01:34:18 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/07/22/pass-zsh-path-to-fish/</guid>
      <description>自分はメインのターミナル環境をfishにしています。
特に設定を細かくしなくてもサクサク動いてくれるので非常に助かっているんですが、POSIX準拠ではないためデフォルトシェルにするのは避けて、以下のような形で利用しています。
 デフォルトシェルはzsh tmuxを自動起動 tmuxのデフォルトシェルとしてfish  そのため、環境変数の設定は全てzshenvでしているんですが、fishを起動したときにzshenvで設定した環境変数の順番を維持してくれないという問題がありました。
普通にfishを起動するだけだと発生する問題のようだったので、以下のようにtmuxでfishを起動する際にzshのパスをそのままの順番でfishのパスに設定する変更することで対応しました。
set -g default-command /usr/local/bin/fish --init-command=&amp;#34;set PATH &amp;#39;string split : $PATH&amp;#39;)&amp;#34; 上記のやり方は直接的な解決方法ではないが、PATHの順序に関するissueは挙がっているので、そのうち直るかもしれません。(深く追う時間が確保できない……)
https://github.com/fish-shell/fish-shell/issues/5456</description>
    </item>
    
    <item>
      <title>FormikとYupを使った動的フォームのバリデーション</title>
      <link>https://nametake.github.io/posts/2019/06/05/formik-yup-dynamic-validation/</link>
      <pubDate>Wed, 05 Jun 2019 23:50:36 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/06/05/formik-yup-dynamic-validation/</guid>
      <description>Formikで動的なFormを作った時に、表示されるFormに応じてYupのバリデーションを切り替える方法でちょっと手間取ったのでメモ。
結論から言うとYup.lazy()を使って遅延評価されるValidationSchemaを使えば解決した。Yup.lazy()に渡ってくるFormの値を元にValidationwSchemaを表示されるFormに対応したValidationSchemaを返せば狙った挙動が実現できました。
サンプルコードは以下。
 </description>
    </item>
    
    <item>
      <title>インライン要素の高さを合わせるCSS定義</title>
      <link>https://nametake.github.io/posts/2019/05/29/inline-center/</link>
      <pubDate>Wed, 29 May 2019 15:47:35 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/05/29/inline-center/</guid>
      <description>ラジオボタンとラベルの高さを合わせるCSS定義を何回も調べている気がするのでメモ。
たぶん下の書き方が一番モダンだと思います。
display: inline-flex; align-items: center;</description>
    </item>
    
    <item>
      <title>Type SafeなReducerの書き方</title>
      <link>https://nametake.github.io/posts/2019/05/18/type-safe-reducer/</link>
      <pubDate>Sat, 18 May 2019 10:38:55 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/05/18/type-safe-reducer/</guid>
      <description>以前書いた記事で書いたReducerでは、受け取ったActionの型を判別するために、switchで分岐した後に対応したActionの型でキャストをする必要がありました。
const todoReducer: Reducer&amp;lt;ITodoState&amp;gt; = ( state: ITodoState = initTodoState, action: TodoAction ): ITodoState =&amp;gt; { switch (action.type) { case TodoActionType.ADD_TODO: const addTodoAction: IAddTodoAction = action; // &amp;lt;-- ここでキャストしている  return { ...state, todos: state.todos.concat([addTodoAction.payload.todo]) }; default: return state; } }; この方法だと、action.typeとそれに対応する型を実装者が気にしなければならず、型安全とは言い切れませんでした。
このあたりの話を某Slackで相談したら、以下のような Flux standard actionのtypeやpayloadをジェネリクスで指定するようにして、typeにenumを使うというやり方を教えてもらいました。
import { Reducer } from &amp;#39;redux&amp;#39;; // Flux standard action interface Action&amp;lt;TType, TPayload = null, TMeta = undefined&amp;gt; { type: TType; payload: TPayload; meta?: TMeta; } enum ActionType { ADD, DELETE } type AddAction = Action&amp;lt;ActionType.</description>
    </item>
    
    <item>
      <title>IntelliJのPopupの候補を展開するKeymap</title>
      <link>https://nametake.github.io/posts/2019/01/20/intellij-popup-expand/</link>
      <pubDate>Sun, 20 Jan 2019 21:05:06 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2019/01/20/intellij-popup-expand/</guid>
      <description>自分は普段Vimでの補完候補を&amp;lt;C-k&amp;gt;で展開しているがIntelliJでの補完候補も同じコマンドで展開したかったのでメモ。
結論だけいうと、Editor Actions -&amp;gt; Choose Lookup ItemにKeymapを設定すればできました。
本当は.ideavimrcだけに設定したかったんですが、ここまで調べるのに少し時間がかかったので後で調べます。</description>
    </item>
    
    <item>
      <title>labelerrとsuberrを作った話をLTしてきた</title>
      <link>https://nametake.github.io/posts/2018/12/19/created-labelerr-and-suberr/</link>
      <pubDate>Wed, 19 Dec 2018 11:37:17 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/19/created-labelerr-and-suberr/</guid>
      <description>golang.tokyo #20のLT大会で、labelerrとsuberrを作った話をしてきました。
 「Goのerrorは1種類というのは綺麗だとは思うけど、実運用上errorに重み付けをしたいよね」ってところからこのライブラリの出発点です。
スライド内にもありますが、Primitiveな型しか取り扱わないように気をつけている上に、ライブラリ自体も難しいことはしてないので、なんとなく使ってみるか、ぐらいの感覚で使ってもらうと嬉しいです。</description>
    </item>
    
    <item>
      <title>Goでのprotocプラグインのテストの書き方</title>
      <link>https://nametake.github.io/posts/2018/12/14/protoc-plugin-test/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/14/protoc-plugin-test/</guid>
      <description>最近周りでProtocol Buffersの話題をよく聞くようになりました。
ということはそろそろ人類はprotocのプラグインを書きたくなる時代がやってくると思います。
そのときに世の中に生み出されるプラグインの品質が少しでも高くなればと思い、以前protoc-gen-gohttpというプラグイン作ったときにテストも書いたので、その知見を書こうと思います。
プラグイン自体は@yuguiさんの「protocプラグインの書き方」がとても参考になったのでそちらを参照すると良いかもしれません。
TL;DR  細かいやり方はgithub.com/golang/protobuf/blob/master/protoc-gen-go/golden_test.goに書いてある  自分のプラグインのテストもそれを参考にして書いた  プラグインの動作テストはテスト内でprotocコマンドを実行して行う 実行結果の確認はGolden testingで行う Goのコードでprotoファイルをplugin.CodeGeneratorRequestに変換することは(恐らく)できない  経緯(読み飛ばして大丈夫です) protocのプラグインは標準入力に入ってきたデータをproto.CodeGeneratorRequest型にUnmarshalしてprotoファイルの情報を取得します。
そのため、最初にテストを書こうとしたときにはGoだけでprotoファイルをproto.CodeGeneratorRequestに変換する仕組みがあるのかと思っていたのですが、この記事公開時点ではその仕組みは提供されていないようでした(知ってたらコメント等で教えていただけると助かります)。
「それじゃあ有名なプラグインはどうやってるんだ?」と思いprotoc-gen-goのコードを見てみると、Goのコードの中で直接protocコマンドを実行していて、少し面白いテストをしていたので解説しようと思います。
golden_test.goの解説 ファイル名から想像できる通り、いわゆるGolden testingと呼ばれるものです。テストの中からprotocコマンドを直接実行して、その結果の出力ファイルとtestdataディレクトリに入っている期待するファイルとを比較をしてテストしています。
300行ぐらいなので全部読んでもそんなに時間はかからないと思いますが、簡単に解説をしてみようと思います。
コマンド実行部分 以下のコードが直接コマンドを実行する部分です。testing.T構造体とprotocに与える引数を受け取って実際にコマンドを実行します。
func protoc(t *testing.T, args []string) { cmd := exec.Command(&amp;#34;protoc&amp;#34;, &amp;#34;--plugin=protoc-gen-go=&amp;#34;+os.Args[0]) cmd.Args = append(cmd.Args, args...) // We set the RUN_AS_PROTOC_GEN_GO environment variable to indicate that 	// the subprocess should act as a proto compiler rather than a test. 	cmd.Env = append(os.Environ(), &amp;#34;RUN_AS_PROTOC_GEN_GO=1&amp;#34;) out, err := cmd.</description>
    </item>
    
    <item>
      <title>TypeScript&#43;React&#43;Reduxチュートリアル</title>
      <link>https://nametake.github.io/posts/2018/12/05/typescript-react-redux-tutorial/</link>
      <pubDate>Wed, 05 Dec 2018 11:08:00 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/05/typescript-react-redux-tutorial/</guid>
      <description>普段は Go でサーバサイドのコードを書いているのですが、TypeScript+React+Redux を勉強する機会がありました。
その際、巷に溢れているチュートリアルやサンプルコードで型で縛っているものが少なすぎて、理解にかなり苦労したので自分なりに Todo アプリケーションを作るチュートリアルを書いておきます。
このチュートリアルは以下のことを意識して書かれています。
 引数や返り値は型で縛る  データフローの理解を重視する  外部ライブラリは以下の 3 つしか import しない  react redux react-redux  標準の設計になるべく則る  また、この記事では以下のことについては深く言及はしません
 nodeのツールのエコシステム TypeScript の記法 JSX の記法 React+Redux の概念  プロジェクトの準備 まずはプロジェクトを準備します。
node と yarn は入っている前提で進めます。
Facebook が公式で用意しているアプリケーション作成ツールを使用してプロジェクトテンプレートを作ります。
npx create-react-app todo-app --scripts-version=react-scripts-ts 次にプロジェクトのディレクトリに移動して以下のツールをインストールします。
cd todo-app yarn add redux react-redux yarn add -D @types/redux @types/react-redux @types がついているパッケージは、/以下のパッケージの型情報が記述されているパッケージです。開発時しか使用しないので-Dオプションを付けてインストールします。
以下のコマンドでローカルサーバが立ち上がり、ブラウザに画面が表示されれば問題ありません。
yarn start チュートリアルのコードは作成されたプロジェクト内部の src ディレクトリに記述していきます。
Component の実装 何はともあれ何かが表示されてないとモチベーションが上がらないのでブラウザに見た目を表示させます。</description>
    </item>
    
    <item>
      <title>VimConf2018感想</title>
      <link>https://nametake.github.io/posts/2018/11/24/vimconf2018/</link>
      <pubDate>Sat, 24 Nov 2018 10:15:34 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/24/vimconf2018/</guid>
      <description>11月24日にあったVimConf2018に行ったので参加ブログを書きます。
Keynote - What is the next feature?(o) スライド
mattnさんの発表。
Keynote - Vim: From hjkl to a platform for plugins 楽しみにしていたBram氏の発表。
Vimの歴史とこれからのVimの話をされていた。
非常に勝手ながらにプラグインにはそこまで興味がないかと思っていたが、発表で言及されていた「これからのVim」はプラグインに関することが多く、少し驚いた。
発表の内容からも、終始開発者として「使う人」のことを強く意識しながらVimのこれからを考えていることが伝わった。
個人的にはVSCodeのPopup Windowが羨ましいのでPopUp Windowがほしいです。
Migrating plugins to standard features  この発表の聽いたので帰ってからVimのプラグインを10個削りました。
Modes  デバッグのお話。
この話を聽いてDelveのプラグインを思い出したのでちょっとあとで試そうと思う。
A day in the life of (ordinary) Vimmer  1日1回プラグインのアップデートは私もやります。
Modern editor-independent development environment for PHP Modern editor-independent development environment for PHP #vimconf / 黒點 さん - ニコナレ 宗教戦争好きですすみません。
Veonimは少し気になったので後で試す。
Effective Modern Vim scripting スライド</description>
    </item>
    
    <item>
      <title>Protocol Buffersのserviceをnet/httpに対応させるprotoc-gen-gohttpを作った</title>
      <link>https://nametake.github.io/posts/2018/11/21/protoc-gen-gohttp/</link>
      <pubDate>Wed, 21 Nov 2018 16:32:07 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/21/protoc-gen-gohttp/</guid>
      <description>nametake/protoc-gen-gohttpというprotocのプラグインを作ったのでその話です。
Protocol Buffersとは Protocol Buffersはインターフェース定義言語の1つでGoogleによって開発されているものです(ざっくりいうと、JSONやXMLの仲間)。以下のように、構造を表すmessageとそのmessageを使ったRPCのインターフェースのserviceというものを定義できます。
syntax = &amp;#34;proto3&amp;#34;;package helloworld;option go_package = &amp;#34;main&amp;#34;;message HelloRequest { string name = 1;}message HelloReply { string message = 1;}service Greeter { rpc SayHello(HelloRequest) returns (HelloReply) {}} 上記の定義をprotocコマンドを使ってコンパイルすることで、対応した言語ならそのままコードを書き出せます。例えばGoなら以下のような構造体が書き出されます(長くなるのでコードは削っています)。以下の構造体はProtocol Bufferが用意しているライブラリを利用すればバイナリに変換できます。
type HelloRequest struct { Name string `protobuf:&amp;#34;bytes,1,opt,name=name&amp;#34; json:&amp;#34;name,omitempty&amp;#34;` XXX_NoUnkeyedLiteral struct{} `json:&amp;#34;-&amp;#34;` XXX_unrecognized []byte `json:&amp;#34;-&amp;#34;` XXX_sizecache int32 `json:&amp;#34;-&amp;#34;` } type HelloReply struct { Message string `protobuf:&amp;#34;bytes,1,opt,name=message&amp;#34; json:&amp;#34;message,omitempty&amp;#34;` XXX_NoUnkeyedLiteral struct{} `json:&amp;#34;-&amp;#34;` XXX_unrecognized []byte `json:&amp;#34;-&amp;#34;` XXX_sizecache int32 `json:&amp;#34;-&amp;#34;` } また、protocコマンドはプラグイン機構も持っているため、例えばgRPCのためのコードを書き出したかったらprotoc --go_out=plugins=grpc:.</description>
    </item>
    
    <item>
      <title>GCPの認証済みのhttp.Clientの取得方法</title>
      <link>https://nametake.github.io/posts/2018/11/09/auth-gcp-client/</link>
      <pubDate>Fri, 09 Nov 2018 11:15:24 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/09/auth-gcp-client/</guid>
      <description>GCPの認証済みのhttp.Clientが欲しいときにちょっとだけ調べたのでメモ。
結論だけ言うと、golang.org/x/oauth2/googleのDefaultClientを使えばいいみたいです。
今回はDataflowのAPIを叩きたかったので以下のようにすればできました。
client, err := google.DefaultClient(ctx, dataflow.CloudPlatformScope) if err != nil { return fmt.Errorf(&amp;#34;failed create client: %v&amp;#34;, err) }</description>
    </item>
    
    <item>
      <title>neoformatでshfmtを使うときにインデントをタブ文字にしたい時の設定</title>
      <link>https://nametake.github.io/posts/2018/10/10/vim-shfmt-neoformat-indent/</link>
      <pubDate>Wed, 10 Oct 2018 11:44:32 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/10/10/vim-shfmt-neoformat-indent/</guid>
      <description>neoformatで使うshfmtはデフォルトだとインデントがスペースなんですが、チームのコーディング規約に合わせてタブ文字にしたかったときにちょっと引っかかったのでメモ。
まずは、shfmt のヘルプとneoformatのshfmtの定義を見てみます。
-i uint indent: 0 for tabs (default), &amp;gt;0 for number of spacesfunction! neoformat#formatters#sh#shfmt() abort return { \ &amp;#39;exe&amp;#39;: &amp;#39;shfmt&amp;#39;, \ &amp;#39;args&amp;#39;: [&amp;#39;-i &amp;#39; . shiftwidth()], \ &amp;#39;stdin&amp;#39;: 1, \ }endfunction shfmtのヘルプから、インデントをタブにしたければ-i引数で0を渡せば良さそうで、neoformatの定義ではインデントの値にshiftwidthの値をしているようだったので、プロジェクトでのVimの設定を以下のように設定してみました(プロジェクト固有の設定ができるようにしている)。
autocmd Filetype sh setlocal sw=0 sts=0 noexpandtab しかし、どうしてもインデントがスペースになってしまうためちゃんとshiftwidth()の挙動を調べてみると、shiftwidthが0に設定されているとtabstopの値を使うようになっているらしい。
https://vim-jp.org/vimmagazine/2012/08/31/vimmagazine.html
tabstopは0を設定できないため、結局以下のようにneoformatのshfmt設定をプロジェクト固有の設定で上書きして対処しました。
let g:neoformat_sh_shfmt = { \ &amp;#39;exe&amp;#39;: &amp;#39;shfmt&amp;#39;, \ &amp;#39;args&amp;#39;: [&amp;#39;-i&amp;#39;, 0], \ &amp;#39;stdin&amp;#39;: 1, \ }</description>
    </item>
    
    <item>
      <title>depでprivateリポジトリがupdateできなかったときの解決策</title>
      <link>https://nametake.github.io/posts/2018/09/20/dep-private-repo/</link>
      <pubDate>Thu, 20 Sep 2018 18:47:46 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/09/20/dep-private-repo/</guid>
      <description>Goをアップデートした後、dep updateをしたら以下のようなエラーが発生しました。
grouped write of manifest, lock and vendor: error while writing out vendor tree: failed to write dep tree: failed to export github.com/nametake/private-repo: unable to update repository: remote: Repository not found. fatal: repository &amp;#39;https://github.com/nametake/private-repo/&amp;#39; not found : command failed: [git fetch --tags --prune origin]: exit status 128 make: *** [dep] Error 1 原因はprivateリポジトリをhttps経由でcloneしようとしたことだったみたいです。
以下のconfig設定をして、githubではhttpsで始まるURLをgitのURLを使うように書き換える設定を追加したら治りました。
[url &amp;#34;git@github.com:&amp;#34;] insteadOf = https://github.com/ https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</description>
    </item>
    
    <item>
      <title>hugo&#43;github pagesにブログを移転したメモ</title>
      <link>https://nametake.github.io/posts/2018/09/15/hugo-github-pages/</link>
      <pubDate>Sat, 15 Sep 2018 12:20:26 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/09/15/hugo-github-pages/</guid>
      <description>大して書いていなかったブログをgithub pages+hugoの組み合わせに移行したのでそのメモ。
とは言うものの、ほとんどHugoの入門用ページの内容をそのままやっただけなのでその辺は割愛。
最終的なディレクトリ構成は以下。
blog ├── Makefile ├── archetypes │ ├── default.md │ └── posts.md ├── bin │ ├── deploy.sh │ └── new_post.sh ├── config.toml ├── content │ ├── about │ │ └── index.md │ └── posts │ └── 2018-09-15-hugo-github-pages │ └── index.md ├── public(submodule) ├── static │ ├── css │ │ └── index.css │ └── images │ └── avatar.jpg └── themes └── coder(submodule) config.toml 自分はパーマリンクを日付+自分で設定した英単語にしたかったので、以下のようにconfig.tomlに追記。
slugは各postのfrontmatter(postの先頭にあるヘッダ部分)に設定すると反映されます。
posts = &amp;quot;/posts/:year/:month/:day/:slug&amp;quot;のpostsの部分はcontentディレクトリにあるpostsディレクトリと同じ名前にする必要があるので注意。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://nametake.github.io/about/</link>
      <pubDate>Sun, 09 Sep 2018 22:52:28 +0900</pubDate>
      
      <guid>https://nametake.github.io/about/</guid>
      <description>I&amp;rsquo;m Software Engineer and Gopher.</description>
    </item>
    
  </channel>
</rss>