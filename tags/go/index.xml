<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on nametake.info</title>
    <link>https://nametake.github.io/tags/go/</link>
    <description>Recent content in Go on nametake.info</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Dec 2018 11:37:17 +0900</lastBuildDate>
    
	<atom:link href="https://nametake.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>labelerrとsuberrを作った話をLTしてきた</title>
      <link>https://nametake.github.io/posts/2018/12/19/created-labelerr-and-suberr/</link>
      <pubDate>Wed, 19 Dec 2018 11:37:17 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/19/created-labelerr-and-suberr/</guid>
      <description>golang.tokyo #20のLT大会で、labelerrとsuberrを作った話をしてきました。
 「Goのerrorは1種類というのは綺麗だとは思うけど、実運用上errorに重み付けをしたいよね」ってところからこのライブラリの出発点です。
スライド内にもありますが、Primitiveな型しか取り扱わないように気をつけている上に、ライブラリ自体も難しいことはしてないので、なんとなく使ってみるか、ぐらいの感覚で使ってもらうと嬉しいです。</description>
    </item>
    
    <item>
      <title>Goでのprotocプラグインのテストの書き方</title>
      <link>https://nametake.github.io/posts/2018/12/14/protoc-plugin-test/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/12/14/protoc-plugin-test/</guid>
      <description>最近周りでProtocol Buffersの話題をよく聞くようになりました。
ということはそろそろ人類はprotocのプラグインをGoで書きたくなる時代がやってくると思います。
そのときに世の中に生み出されるプラグインの品質が少しでも高くなればと思い、以前protoc-gen-gohttpというプラグイン作ったときにテストも書いたので、その知見を書こうと思います。
プラグイン自体は@yuguiさんの「protocプラグインの書き方」がとても参考になったのでそちらを参照すると良いかもしれません。
TL;DR  細かいやり方はgithub.com/golang/protobuf/blob/master/protoc-gen-go/golden_test.goに書いてある  自分のプラグインのテストもそれを参考にして書いた  プラグインの動作テストはテスト内でprotocコマンドを実行して行う 実行結果の確認はGolden testingで行う Goのコードでprotoファイルをplugin.CodeGeneratorRequestに変換することは(恐らく)できない  経緯(読み飛ばして大丈夫です) protocのプラグインは標準入力に入ってきたデータをproto.CodeGeneratorRequest型にUnmarshalしてprotoファイルの情報を取得します。
そのため、最初にテストを書こうとしたときにはGoだけでprotoファイルをproto.CodeGeneratorRequestに変換する仕組みがあるのかと思っていたのですが、この記事公開時点ではその仕組みは提供されていないようでした(知ってたらコメント等で教えていただけると助かります)。
「それじゃあ有名なプラグインはどうやってるんだ?」と思いprotoc-gen-goのコードを見てみると、Goのコードの中で直接protocコマンドを実行していて、少し面白いテストをしていたので解説しようと思います。
golden_test.goの解説 ファイル名から想像できる通り、いわゆるGolden testingと呼ばれるものです。テストの中からprotocコマンドを直接実行して、その結果の出力ファイルとtestdataディレクトリに入っている期待するファイルとを比較をしてテストしています。
300行ぐらいなので全部読んでもそんなに時間はかからないと思いますが、簡単に解説をしてみようと思います。
コマンド実行部分 以下のコードが直接コマンドを実行する部分です。testing.T構造体とprotocに与える引数を受け取って実際にコマンドを実行します。
func protoc(t *testing.T, args []string) { cmd := exec.Command(&amp;#34;protoc&amp;#34;, &amp;#34;--plugin=protoc-gen-go=&amp;#34;+os.Args[0]) cmd.Args = append(cmd.Args, args...) // We set the RUN_AS_PROTOC_GEN_GO environment variable to indicate that 	// the subprocess should act as a proto compiler rather than a test. 	cmd.Env = append(os.Environ(), &amp;#34;RUN_AS_PROTOC_GEN_GO=1&amp;#34;) out, err := cmd.</description>
    </item>
    
    <item>
      <title>Protocol Buffersのservice定義をhttp.Handler対応させるprotoc-gen-gohttpを作った</title>
      <link>https://nametake.github.io/posts/2018/11/21/protoc-gen-gohttp/</link>
      <pubDate>Wed, 21 Nov 2018 16:32:07 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/21/protoc-gen-gohttp/</guid>
      <description>nametake/protoc-gen-gohttpというprotocのプラグインを作ったのでその話です。
Protocol Buffersとは Protocol Buffersはインターフェース定義言語の1つでGoogleによって開発されているものです(ざっくりいうと、JSONやXMLの仲間)。以下のように、構造を表すmessageとそのmessageを使ったRPCのインターフェースのserviceというものを定義できます。
syntax = &amp;#34;proto3&amp;#34;;package helloworld;option go_package = &amp;#34;main&amp;#34;;message HelloRequest { string name = 1;}message HelloReply { string message = 1;}service Greeter { rpc SayHello(HelloRequest) returns (HelloReply) {}} 上記の定義をprotocコマンドを使ってコンパイルすることで、対応した言語ならそのままコードを書き出せます。例えばGoなら以下のような構造体が書き出されます(長くなるのでコードは削っています)。以下の構造体はProtocol Bufferが用意しているライブラリを利用すればバイナリに変換できます。
type HelloRequest struct { Name string `protobuf:&amp;#34;bytes,1,opt,name=name&amp;#34; json:&amp;#34;name,omitempty&amp;#34;` XXX_NoUnkeyedLiteral struct{} `json:&amp;#34;-&amp;#34;` XXX_unrecognized []byte `json:&amp;#34;-&amp;#34;` XXX_sizecache int32 `json:&amp;#34;-&amp;#34;` } type HelloReply struct { Message string `protobuf:&amp;#34;bytes,1,opt,name=message&amp;#34; json:&amp;#34;message,omitempty&amp;#34;` XXX_NoUnkeyedLiteral struct{} `json:&amp;#34;-&amp;#34;` XXX_unrecognized []byte `json:&amp;#34;-&amp;#34;` XXX_sizecache int32 `json:&amp;#34;-&amp;#34;` } また、protocコマンドはプラグイン機構も持っているため、例えばgRPCのためのコードを書き出したかったらprotoc --go_out=plugins=grpc:.</description>
    </item>
    
    <item>
      <title>GCPの認証済みのhttp.Clientの取得方法</title>
      <link>https://nametake.github.io/posts/2018/11/09/auth-gcp-client/</link>
      <pubDate>Fri, 09 Nov 2018 11:15:24 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/11/09/auth-gcp-client/</guid>
      <description>GCPの認証済みのhttp.Clientが欲しいときにちょっとだけ調べたのでメモ。
結論だけ言うと、golang.org/x/oauth2/googleのDefaultClientを使えばいいみたいです。
今回はDataflowのAPIを叩きたかったので以下のようにすればできました。
client, err := google.DefaultClient(ctx, dataflow.CloudPlatformScope) if err != nil { return fmt.Errorf(&amp;#34;failed create client: %v&amp;#34;, err) }</description>
    </item>
    
    <item>
      <title>depでprivateリポジトリがupdateできなかったときの解決策</title>
      <link>https://nametake.github.io/posts/2018/09/20/dep-private-repo/</link>
      <pubDate>Thu, 20 Sep 2018 18:47:46 +0900</pubDate>
      
      <guid>https://nametake.github.io/posts/2018/09/20/dep-private-repo/</guid>
      <description>Goをアップデートした後、dep updateをしたら以下のようなエラーが発生しました。
grouped write of manifest, lock and vendor: error while writing out vendor tree: failed to write dep tree: failed to export github.com/nametake/private-repo: unable to update repository: remote: Repository not found. fatal: repository &amp;#39;https://github.com/nametake/private-repo/&amp;#39; not found : command failed: [git fetch --tags --prune origin]: exit status 128 make: *** [dep] Error 1 原因はprivateリポジトリをhttps経由でcloneしようとしたことだったみたいです。
以下のconfig設定をして、githubではhttpsで始まるURLをgitのURLを使うように書き換える設定を追加したら治りました。
[url &amp;#34;git@github.com:&amp;#34;] insteadOf = https://github.com/ https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</description>
    </item>
    
  </channel>
</rss>